---
id: react
title: react
author: Adrian Yang
author_title: Front End Engineer @ Facebook
author_url: https://github.com/Druidss
author_image_url: https://avatars2.githubusercontent.com/u/40681152?s=460&u=e324c1f3465c768888c1fcf798b5f5eb1be9d60d&v=4
tags: [JavaScript, react, JavascriptProblem]
---

# Lektion 1 React

### 1.1 React

1. 用于构建动态用户界面的 JavaScript库 (只关注于View)
2. 由 Facebook 开源

React 特点

1. Declarative 声明式编码
2. Component-Based 组件化编码
3. Learn Once Write Anywhere (React Native / 支持客户端与服务端渲染)
4. 高效
5. 单项数据流

### 1.2JSX

JavascriptXML

是React 定义的一种类似XML 的JS 拓展语法 XML + JS (XML 语法严谨 标签闭合)

本质是 React.createElement(component,props,...children)

作用:

用来创建React 虚拟DOM对象

注意

- 遇到<  按HTML 语法解析  遇到{  按JS语法解析  JS 表达式用 { }包含
- 只有一个根标签
- 写样式的时候使用 clasName
- 

**// JS 表达式 和  JS 代码的区别**

JS 表达式: 一个表达式会产生一个`数值`  可以放在任何一个需要值的地方  3+a  arr.map();

JS 语句: 可以理解成一个`行为` 循环语句 for 语句

React 高效的原因

虚拟DOM. 并不是直接操作DOM  DOM Diff 算法,最小化页面重绘

DOM DIff 算法就是依赖key



### 1.3  模块化 与 组件模块化 与 组件化 

理解:  向外提供特定功能的js 程序 

作用: 复用js 简化 js 间歇 提高js运行效率



组件

理解:  用来是实现(特定)页面效果的代码集合

作用: 简化项目编码



# Lektion 2 面向组件编程

### 2.1 state

自身内部可变化的数据

工厂函数模式 ( 简单组件  无状态)

```jsx
function Mycomponent(){
    console.log(this)  //undefined  Babel 编译使用严格模式 禁止自定义函数指向window
    return <h2>Hallo</h2>
}
// 渲染组件标签到页面

//让 react 自动触发与组件标签同名的工厂函数调用
ReactDOM.render(<Mycomponent/>,document.getElementById('example'))
```



使用ES6 类组件 (有状态 / 复杂组件 )

- 组件的状态不可以直接更新  setState()
- 组件状态不可以直接修改  数据深度绑定的时候会出错
- 如果以Es6 形式定义组件, 那么React底层将所有自定义的方法中的this 全部修改为undefined

```jsx
class MyComponent extends React.Component{
    constructor(props){
        super(props);
        this.state = {isHot:true}  // 升级成 直接进行赋值
        this.clickHandler = this.clickHandler.bind(this)  //升级成箭头函数 this便指向实例对象
    }
    
    state = {isHot:true}
    
    clickHandler(){
		let {ishot} = this.state //解构赋值
        isHot = !isHot
        this.setState = ({isHot}); //组件的状态不可以直接更新
      	console.log(this);
        //如果以Es6 形式定义组件,那么React底层将所有自定义的方法中的this 全部修改为undefined                 
    }
    
    render(){  // 重写父类继承的 render()
        console.log(this);
        return <h2>Es6 Class</h2>
    }
}
// 类里面都是赋值语句..
```



### 2.2 props

从外部组件向组件内部传递数据 组件内部只读不修改

三点运算符 / 展开语法

函数调用接收参数的时候使用: (解包)

```js
let arr = [2,3,5]
let result = sum(...arr)
```

函数接收参数 (参数的个数不固定)



```js
function(...data){
    let result = 0;
    data.forEach((item)=>{
        result+=item;
    })
    data.reduce((pre,now)=>{
        return pre + now;
    })
}
```

// map 加工数组 形成一个新数组. 

reduce 方法 连续操作器

构造字面量对象时, 进行克隆或者属性的拷贝

```js
let objClone = { ...obj } //浅克隆
```



约束 (限制参数类型  以及必要性的库 )

```jsx
//使用 prop-types 库进行限制
Person.propTypes = {
    name.ProTypes.string.isRequired;
}

Person.defaultProps = {
    age:18,
}
```

**State  和  props 的区别**

自身内部可变化的数据 

从外部组件向组件内部传递数据 组件内部`只读不修改`



### 2.3 ref 与 事件处理

回调ref 方式



createRef 方式

### 2.4 功能页面组件的拆分

1. 拆分页面 抽取组件
2. 实现静态组件
3. 实现动态组件
   1. 动态显示初始化数据
      1. 数据类型
      2. 数据名称
      3. 保存在哪个组件
4. 交互  绑定监听事件



### 2.5 受控组件 非受控组件

受控组件:自动向状态里维护 onChange()

非受控组件: refs 里面去拿



### 2.6 组件的生命周期

触发条件:

ReactDOM.render(`<Mycomponent/>`)

constructor()

componentWillMount()  --> `getDerivedStateFromProps(props,state)`,   return null;

render() 提供虚拟DOM 可能以后调用1+N次

componentDidMount() 启动定时器  发送Ajax请求 只执行一次

=== 

更新: this.setState({})组件改变State

componentWillUpdate()  ->   `getDerivedStateFromProps(props,state)`

render()

getSnapshotBeforeUpdate(props,state)  return value;

componentDidUpdate(props,state,data)

===

卸载 触发条件 ReactDom.ummountComponentAtNode()

componentWillUnmount()  清除定时器



### Lektion DOM Diff 算法

**react / vue 中key的作用?**

**为什么列表的key尽量不要用index?**

Key 作为虚拟DOM 对象的标识

详细的说: 当状态数据发生变化的时候,React 生成新的虚拟DOM,随后React 将之前的旧虚拟DOM 与 新的虚拟DOM进行Diff比较.

- 旧的虚拟ＤＯＭ中找到与新虚拟DOM 相同的key
  - 若虚拟DOM 没变 则直接使用原来真实的DOM
  - 若虚拟DOM 改变, 先更新虚拟DOM 随后刷新页面的真实DOM
- 旧的虚拟ＤＯＭ中 `未找到` 与新虚拟DOM 相同的key
  - 根据i数据创建新的虚拟DOM 随后渲染到真实页面



key 为index 可能会产生的问题

- 添加 删除 排序 会产生不必要的真实DOM 的更新 => 页面效果没问题 但是效率低
- 如果item 界面还有输入类DOM  => 产生错误的真实DOM更新 (输入框残留)

解决办法: 使用数据的唯一表示



# React 应用

###  3.1React 脚手架

安全 + 方便 

自动翻译jsx  自动打开浏览器  压缩  检查 扩展前缀 工程化 组件 ---> 文件夹

- 包含了所有需要的配置
- 指定好了所有的依赖
- 可以直接安装 编译 运行一个简单的效果

项目的整体技术架构为: react + webpack + es6 + eslint

使用脚手架开发的特点: 模块化 组件化 工程化

### 3.1.1 React脚手架项目结构



### 3.2 demo 评论管理

特别注意

state中的数据不能直接修改 和 更新

```jsx
let {comments} = this.state; 
//不要这样获取状态中 [对象类型] 的数据,后期可能会产生一些问题

let comments = [...this.state.comments]
```



# Lektion 4 React Ajax





