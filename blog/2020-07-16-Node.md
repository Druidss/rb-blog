---

id: Node
title: Node
author: Adrian Yang
author_title: Front End Engineer
author_url: https://github.com/Druidss
author_image_url: https://avatars2.githubusercontent.com/u/40681152?s=460&u=e324c1f3465c768888c1fcf798b5f5eb1be9d60d&v=4
tags: [Node, JavaScript, module, FroneEnd]
---

# Node.js

基于ChromeV8 引擎的 Javascript 操作

![image-20200714203552836](C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20200714203552836.png)

NodeJS 优点

1.  异步非阻塞的I/O（I/O线程池）

2. 特别适用于I/O密集型应用

3. 事件循环机制 (与浏览器不一样)

4. 单线程 (成也单线程,败也单线程,对比java服务器)

5. 跨平台

单线程如果想实现"异步",就要有自己的事件循环机制

不足之处

1. 回调函数过多 产生回调地狱
2. 单线程 处理不好CPU 密集型任务

跨平台如何实现

1. js 引擎 -> 谷歌等
2. java -> JVM 虚拟机 -> 
3. Node.js 

**CPU 密集型**

一些进程绝大多数时间在计算上，称为计算密集型（CPU密集型）computer-bound。一些大量循环的代码（例如：图片处理、视频编码）就是CPU密集型

**IO密集型**

有一些进程则在input 和output上花费了大多时间，称为I/O密集型，I/O-bound。比如搜索引擎蜘蛛大多时间是在等待相应这种就属于I/O密集型。

# Lektion 1

### Node 中函数的特点

1.Node中任何一个模块（js文件）都被一个外层函数所包裹

* function (exports, require, module, __filename, __dirname) {}

* exports：用于支持CommonJs模块化规范的暴露语法

* require：用于支持CommonJs模块化规范的引入语法

* module：用于支持CommonJs模块化规范的暴露语法

* __filename：当前运行文件的绝对路径

* __dirname：当前运行文件所在文件夹的绝对路径

  

2.为什么要设计这个外层函数（这个外层函数有什么作用？）

* 1).用于支持模块化语法

* 2).隐藏服务器内部实现(从作用域角度去看)

外层函数，外层函数到底接收了什么参数？
console.log(arguments.callee.toString()) //输出外层函数

### Node 中 Global

1.浏览器端，js由哪几部分组成？

*  1.BOM ----> window 浏览器对象模型 -------- 很多的API（location，history）
*  2.DOM ----> document 文档对象模型 ---------- 很多的API（对DOM的增删改查）
*  3.ES规范 -------------------- ES5、ES6.....

2.Node端，js由几部分组成？

*   1.没有了BOM ----->  因为服务器不需要（服务端没有浏览器对象）
*   2.没有了DOM ----->  因为没有浏览器窗口
*   3.几乎包含了所有的ES规范
*   4.没有了window，但是取而代之的是一个叫做`global`的全局变量。

3.global的一些常用属性

clearImmediate:清空立即执行函数
clearInterval:清除循环定时器
clearTimeout: 清除延迟定时器

setImmediate:设置立即执行函数
setInterval:设置循环定时器
setTimeout: 设置延迟定时器

在Node中禁止函数的this指向global，而是指向了一个空对象 { }



### Node_EventLoop

```bash
   ┌───────────────────────────┐
┌─>│           timers          │定时器阶段: 开始计时 执行定时器回调
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │系统阶段
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │准备阶段
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │  轮询阶段
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │ 专门用于执行setImmediate所设置的回调
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │闭回调阶段
   └───────────────────────────┘
   
   process.nextTick() //设置立即执行函数  ----能在任意阶段优先执行
```

**Poll 轮询阶段 !important**

           ---如果回调队列里有待执行的回调函数
                从回调队列中取出回调函数，同步执行(一个一个执行)，直到回调队列为空了，或者达到系统最大限度。
            ---如果回调队列为空
                  ---如果有设置过setImmediate
                      进入下一个check阶段，目的：为了执行setImmediate所设置的回调。
                  ---如果未设置过setImmediate
                      在此阶段停留，等待回调函数被插入回调队列。
                      若定时器到点了，进入下一个check阶段，
                      原因：为了走第五阶段，随后走第六阶段，随后第一阶段(最终目的)