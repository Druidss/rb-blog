---
l9u y789
id: Node
title: Node
author: Adrian Yang
author_title: Front End Engineer
author_url: https://github.com/Druidss
author_image_url: https://avatars2.githubusercontent.com/u/40681152?s=460&u=e324c1f3465c768888c1fcf798b5f5eb1be9d60d&v=4
tags: [Node, JavaScript, module, FroneEnd]
---

# Node.js

基于ChromeV8 引擎的 Javascript 运行时

![image-20200714203552836](C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20200714203552836.png)

NodeJS 优点

1.  异步非阻塞的I/O（I/O线程池）

2. 特别适用于I/O密集型应用

3. 事件循环机制 (与浏览器不一样)

4. 单线程 (成也单线程,败也单线程,对比java服务器)

5. 跨平台

单线程如果想实现"异步",就要有自己的事件循环机制

不足之处

1. 回调函数过多 产生回调地狱
2. 单线程 处理不好CPU 密集型任务

跨平台如何实现

1. js 引擎 -> 谷歌等
2. java -> JVM 虚拟机 -> 
3. Node.js 

**CPU 密集型**

一些进程绝大多数时间在计算上，称为计算密集型（CPU密集型）computer-bound。一些大量循环的代码（例如：图片处理、视频编码）就是CPU密集型

**IO密集型**

有一些进程则在input 和output上花费了大多时间，称为I/O密集型，I/O-bound。比如搜索引擎蜘蛛大多时间是在等待相应这种就属于I/O密集型。

# Lektion 1

### Node 中函数的特点

1.Node中任何一个模块（js文件）都被一个外层函数所包裹

* function (exports, require, module, __filename, __dirname) {}

* exports：用于支持CommonJs模块化规范的暴露语法

* require：用于支持CommonJs模块化规范的引入语法

* module：用于支持CommonJs模块化规范的暴露语法

* __filename：当前运行文件的绝对路径

* __dirname：当前运行文件所在文件夹的绝对路径

  

2.为什么要设计这个外层函数（这个外层函数有什么作用？）

* 1).用于支持模块化语法

* 2).隐藏服务器内部实现(从作用域角度去看)

外层函数，外层函数到底接收了什么参数？
console.log(arguments.callee.toString()) //输出外层函数



### Node 中 Global

1.浏览器端，js由哪几部分组成？

*  1.BOM ----> window 浏览器对象模型 -------- 很多的API（location，history）
*  2.DOM ----> document 文档对象模型 ---------- 很多的API（对DOM的增删改查）
*  3.ES规范 -------------------- ES5、ES6.....

2.Node端，js由几部分组成？

*   1.没有了BOM ----->  因为服务器不需要（服务端没有浏览器对象）
*   2.没有了DOM ----->  因为没有浏览器窗口
*   3.几乎包含了所有的ES规范
*   4.没有了window，但是取而代之的是一个叫做`global`的全局变量。

3.global的一些常用属性

clearImmediate:清空立即执行函数
clearInterval:清除循环定时器
clearTimeout: 清除延迟定时器

setImmediate:设置立即执行函数
setInterval:设置循环定时器
setTimeout: 设置延迟定时器

在Node中禁止函数的this指向global，而是指向了一个空对象 { }



### Node_EventLoop

```bash
   ┌───────────────────────────┐
┌─>│           timers          │定时器阶段: 开始计时 执行定时器回调
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │系统阶段
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │准备阶段
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │  轮询阶段
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │ 专门用于执行setImmediate所设置的回调
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │关闭闭回调阶段
   └───────────────────────────┘
   
   process.nextTick() //设置立即执行函数  ----能在任意阶段优先执行
```

**Poll 轮询阶段 !important**

           ---如果回调队列里有待执行的回调函数
                从回调队列中取出回调函数，同步执行(一个一个执行)，直到回调队列为空了，或者达到系统最大限度。
            ---如果回调队列为空
                  ---如果有设置过setImmediate
                      进入下一个check阶段，目的：为了执行setImmediate所设置的回调。
                  ---如果未设置过setImmediate
                      在此阶段停留，等待回调函数被插入回调队列。
                      若定时器到点了，进入下一个check阶段，
                      原因：为了走第五阶段，随后走第六阶段，随后第一阶段(最终目的)



### 包 与 npm 管理器

如何让一个普通文件夹变成一个包？
        让这个文件夹拥有一个：package.json文件即可,且package.json里面的内容要合法。
        执行命令：npm init
        包名的要求: 不能有大写字母、同时尽量不要以数字开头、不能与npm仓库上其他包同名。

### **npm的常用命令？**

    一、【搜索】：
            1.npm search xxxxx (不推荐)
            2.通过网址搜索：www.npmjs.com
    二、【安装】：(安装之前必须保证文件夹内有package.json，且里面的内容格式合法)
    
            1.npm install xxxxx --save   或   npm i xxxx -S   或   npm i xxxx
                备注：
                (1).局部安装完的第三方包，放在当前目录中node_modules这个文件夹里
                (2).安装完毕会自动产生一个package-lock.json(npm版本在5以后才有)，里面缓存的是每个下载过的包的地址，目的是下次安装时速度快一些。
                (3).当安装完一个包，该包的名字会自动写入到package.json中的【dependencies(生产依赖)】里。npm5及之前版本要加上--save后缀才可以。
    
            2.npm install xxxxx --save-dev  或  npm i xxxxx -D  安装包并将该包写入到【devDependencies(开发依赖中)】
              备注：什么是生产依赖与开发依赖？
                    1.只在开发时(写代码时)时才用到的库，就是开发依赖-例如：语法检查、压缩代码、扩展css前缀的包。
                    2.在生产环境中(项目上线)不可缺少的，就是生产依赖 ------ 例如：jquery、bootStrap等等。
                    3.注意：某些包即属于开发依赖，又属于生产依赖 -------例如：jquery。
    
            3.npm i xxxx -g  全局安装xxxx包（一般来说，带有指令集的包要进行全局安装，例如：browserify、babel等）
              全局安装的包，其 [指令] 到处可用，如果该包不带有指令，就无需全局安装。
              查看全局安装的位置：npm root -g
    
            4.npm i xxx@yyy :安装xxx包的yyy版本
    
            5.npm i ：安装package.json中声明的所有包
    
      三、【移除】：
            npm remove xxxxx  在node_module中删除xxxx包，同时会删除该包在package.json中的声明
    
      四、【其他命令】：
            1.npm aduit fix :检测项目依赖中的一些问题，并且尝试着修复。
    
            2.npm view xxxxx versions :查看远程npm仓库中xxxx包的所有版本信息
    
            3.npm view xxxxx version :查看npm仓库中xxxx包的最新版本
    
            4.npm ls xxxx :查看我们所安装的xxxx包的版本
    
       五、【关于版本号的说明】：
            "^3.x.x" ：锁定大版本，以后安装包的时候，保证包是3.x.x版本，x默认取最新的。
            "~3.1.x" ：锁定小版本，以后安装包的时候，保证包是3.1.x版本，x默认取最新的。
            "3.1.1" ：锁定完整版本，以后安装包的时候，保证包必须是3.1.1版本。

替换npm仓库地址为淘宝镜像地址
命令：```npm config set registry https://registry.npm.taobao.org```，
查看是否更改成功：```npm config get registry ```，以后安装时，依然用npm命令，但是实际是从淘宝国内服务器下载的



### yarn的简介与使用

> Yarn发布于2016年10月，截至当前2019年1月，gitHub上的Start数量为：34.3k，已经超过npm很多了，
> yarn使用本地缓存，有时甚至无需互联网连接就能安装本地已经缓存过的依赖项，安装方法：```npm install -g yarn```

#### 特别注意！

由于yarn的全局安装位置与npm不同，所以要配置yarn的全局安装路径到环境变量中，否则全局安装的包不起作用。
具体操作如下：

> 安装yarn后分别执行 ```yarn global dir```命令，```yarn global bin```命令。
> 将上述两步返回的路径配置到电脑环境变量中即可。

#### yarn命令与npm命令的对应关系如下：

#### 初始化项目:

	yarn init -y
	npm init -y

#### 下载项目的所有声明的依赖: 
	yarn
	npm install

#### 下载指定的运行时依赖包: 
	yarn add xxxx@3.2.1
	npm install xxxxx@3.2.1 -S

#### 下载指定的开发时依赖: 
	yarn add xxxxx@3.2.1 -D
	npm install xxxxx@3.2.1 -D

#### 全局下载指定包: 
	yarn global add xxxxxx
	npm install xxxxxxx -g

#### 删除依赖包: 
	yarn remove xxxxx
	yarn global remove xxxxxx
	npm remove xxxxxxx -g

#### 查看某个包的信息: 
	yarn info xxx
	npm info xxx

#### 设置淘宝镜像: 
	yarn config set registry https://registry.npm.taobao.org
	npm config set registry https://registry.npm.taobao.org


# Lektion 2 Buffer  缓冲器

## Buffer

 Buffer是什么？
*    1.它是一个【类似于数组】的对象，用于存储数据（存储的是二进制数据）。
*    2.Buffer的效率很高，存储和读取很快，它是直接对计算机的内存进行操作。
*    3.Buffer的大小一旦确定了，不可修改。
*    4.每个元素占用内存的大小为1字节。8位(bit) = 1字节(Byte)
*    5.Buffer是Node中的非常核心的模块，无需下载、无需引入,直接即可使用



创建一个Buffer的实例对象--------性能特别差-- 为什么?---1.在堆里开辟空间 + 2.清理

```js
let buf = new Buffer(10)
console.log(buf)
```



创建一个Buffer的实例对象--------性能比new Buffer()稍强一点------在堆中开辟一块空间(该块空间没有人用过)

```js
let buf2 = Buffer.alloc(10)
console.log(buf2)
```



创建一个Buffer的实例对象-------性能最好的-------在堆里开辟空间

```js
let buf3 = Buffer.allocUnsafe(10)
console.log(buf3)
```

* 1.输出的Buffer为什么不是二进制？ ----- 输出的是16进制，但是存储的是二进制码，输出的时候会自动转16进制。
* 2.输出的Buffer不为空？ ----- 在堆里开辟空间，可能残留着别人用过的数据，所以allocUnsafe

  

 将数据存入一个Buffer实例

```js
let buf4 = Buffer.from('hello')
console.log(buf4)
```

* 1.输出的为什么不是我们曾经存入的字符串？:用户存储的不一定是字符串，可能是媒体类型的文件
* 2.如何能够让输出的东西是字符串(我们能看懂的)？ ->  toString()

  

# **Node中的文件系统**

* 1.在NodeJs中有一个文件系统，所谓的文件系统，就是对计算机中的文件进行增删改查等操作。

* 2.在NodeJs中，给我们提供了一个模块，叫做fs模块(文件系统)，专门用于操作文件。

* 3.fs模块是Node的核心模块，使用的时候，无需下载，直接引入。



### **### 异步文件写入 （简单文件写入）**

`fs.writeFile(file, data[, options], callback)`

* --file：要写入的文件路径+文件名+后缀
* --data：要写入的数据
* --options：配置对象(可选参数)
  *                 --encoding:设置文件的编码方式，默认值：utf8(万国码)

  *                  --mode:设置文件的操作权限，默认值是：0o666 = 0o222 + 0o444
  
                    * --0o111:文件可被执行的权限  .exe .msc 几乎不用，linux有自己一套操作方法。
  
                    * --0o222:文件可被写入的权限
  
                    *                 --0o444:文件可别读取的权限
* --flag:打开文件要执行的操作，默认值是'w'
  *                      --a ：追加
  *                      --w ：写入
* --callback：回调函数
  * --err：错误对象



*  在Node中有这样一个原则：错误优先

```js
//引入内置的fs模块
let fs = require('fs')

//调用writeFile方法`
fs.writeFile(__dirname+'/demo.txt','kobe,123',{mode:0o666,flag:'w'},err => {
    if(err) console.log('文件写入失败',err)
    else console.log('文件写入成功')
})

```



### 流式文件写入

创建一个可写流

`fs.createWriteStream(path[, options])`

*       --path:要写入文件的路径+文件名+文件后缀
*   --options：配置对象（可选参数）
    *           --flags:
    *           --encoding :
    *           --fd : 文件统一标识符，linux下文件标识符
    *           --mode :
    *           --autoClose : 自动关闭 --- 文件，默认值：true
    *           --emitClose : 关闭 --- 文件，默认值：false
    *           --start : 写入文件的起始位置(偏移量)

```js
let fs = require('fs')

//创建一个可写流----水管到位了
let ws = fs.createWriteStream(__dirname+'/demo.txt',{start:10})
.23w5edtg46r5h6u7j8i9k0o[867yhbnjmk,olp;'[\]
                         [':?;'[-'p;/.']]'/
ws.on('open',function () {
  console.log('可写流打开了')
})
ws.on('close',function () {
  console.log('可写流关闭了')
})

//使用可写流写入数据
ws.write('美女\n')
ws.write('霉女？\n')
ws.write('到底是哪一个？\n')
//ws.close() //如果在Node的8版本中，使用此方法关闭流会造成数据丢失
ws.end() //在Node的8版本中，要用end方法关闭流
```



### 简单文件读取:

`fs.readFile(path[, options], callback)`

*     --path：要读取文件的路径+文件名+后缀
*     --options：配置对象（可选）
*     --callback：回调
      *         --err：错误对象
      *         --data：读取出来的数据

简单文件写入和简单文件读取，都是`一次性`把所有要读取或要写入的内容加到内存中，容易造成内存泄露。`

```js
let fs = require('fs')

fs.readFile(__dirname+'/test.mp4',function (err,data) {
    if(err) console.log(err)
    //为什么读取出来的东西是Buffer？ :用户存储的不一定是纯文本
    else console.log(data)
    fs.writeFile('../test.mp4',data.function(err){
    	if(err) console.log(err)
    	else console.log('sucess!')
    })
})
```



### 流式文件读取:

`fs.createReadStream(path[, options])`

*         --start ：起始偏移量
*         --end : 结束偏移量
*         --highWaterMark：每次读取数据的大小，默认值是64 * 1024

```js
let {createReadStream,createWriteStream} = require('fs')

//创建一个可读流
let rs = createReadStream(__dirname+'/music.mp3',{
  highWaterMark:10 * 1024 * 1024,
  //start:60000,
  //end:120000
})

//创建一个可写流
let ws = createWriteStream('../haha.mp3')

//只要用到了流，就必须监测流的状态
rs.on('open',function () {
  console.log('可读流打开了')
})
rs.on('close',function () {
  console.log('可读流关闭了')
  ws.close()  !
})

ws.on('open',function () {
  console.log('可写流打开了')
})
ws.on('close',function () {
  console.log('可写流关闭了')
})

//给可读流绑定一个data事件，就会触发可读流自动读取内容。
rs.on('data',function (data) {
  //Buffer实例的length属性，是表示该Buffer实例占用内存空间的大小
  console.log(data.length) //输出的是65536，每次读取64KB的内容 (size)
  ws.write(data)
  //ws.close() //若在此处关闭流，会写入一次，后续数据丢失
})
//ws.close() //若在此处关闭流，导致无法写入数据

//小文件可以直接用简单文件的读写，大文件最好用流式的文件读写
```



# 数据库

### 关系型数据库

代表有：MySQL、Oracle、DB2、SQL Server...

特点：关系紧密，都是表

优点：

1. 易于维护：都是使用表结构，格式一致；

2. 使用方便：SQL语言通用，可用于复杂查询；

3. 高级查询：可用于一个表以及多个表之间非常复杂的查询。

缺点：

1. 读写性能比较差，尤其是海量数据的高效率读写；

2. 有固定的表结构，字段不可随意更改，灵活度稍欠；

3. 高并发读写需求，传统关系型数据库来说，硬盘I/O是一个很大的瓶颈。

### 非关系型数据库 NoSQL

代表有：MongoDB、Redis...

特点：关系不紧密，有文档，有键值对

优点：

1、格式灵活：存储数据的格式可以是key,value形式。

2、速度快：nosql可以内存作为载体，而关系型数据库只能使用硬盘；

3、易用：nosql数据库部署简单。

缺点：

1、不支持sql，学习和使用成本较高；

2、不支持事务；[原子性, 不可分割性]

3、复杂查询时语句过于繁琐。