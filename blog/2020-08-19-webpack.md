---
id: webpack
title: webpack
author: Adrian Yang
author_title: Front End Engineer
author_url: https://github.com/Druidss
author_image_url: https://avatars2.githubusercontent.com/u/40681152?s=460&u=e324c1f3465c768888c1fcf798b5f5eb1be9d60d&v=4
tags: [webpack, JavaScript, FrontEnd]
---

# 构建工具

构建： 将源代码，经过编译压缩，语法检查，兼容性处理，生成浏览器可以高效，稳定运行的代码

 

# Webpack

## 什么是webpack

- webpack 是一个模块打包器（bundler）
- 在webpack 看来，前端所有的静态文件（js/json/css/img/less..） 都会被视作`模块`来处理
- 它将根据模块的以来关系进行静态分析,生成对应的静态资源

<!--truncate-->



### 五个核心概念

- Entry: 入口起点(entry point) 指示webpack应该使用哪个模块, 来作为构建其内部依赖图的开始
- Output: output 属性告诉 webpack 在哪里输出它创建的 bundles, 以及如何命名这些文件 默认值为 ./dist
- Loader: loader 让 webpack 能够处理那些非JavaScript文件 (webpack 本身只能解析JavaScript / jason)
- Plugins: 插件则可以用于执行范围更广的任务, 插件的范围包括: 从打包 优化 压缩 一直到重新定义环境中的变量等.
- Mode: 模式, 有生产模式production () 和 开发模式 development

#### 理解 Loader

- webpack 本身只能加载JS / JSON 模块, 如果要加载其他类型的文件(模块), 就需要使用对应的loader 进行转换  /  加载
- Loader 本身也是运行在node.js 环境中的 JavaScript模块
- 它本身是一个函数,接受源文件作为参数, 返回转换的结果
- Loader 一般以 xxx-loader 的方式命名, xxx 代表这个loader的转换功能(json-loader)

#### 理解Plugins

- 插件可以完成一些loader 不能完成的功能
- 插件的使用一般是在 webpack 的配置信息 plugins 选项中指定



### 运行指令

```bash
$: npm install webpack webpack -g 
$: npm install webpack webpack-cli -g 
$: npm install webpack webpack-cli -D
$: webpack src/js/app.js -o /dist/js/app.js  --mode development 
//  打包JS 和  JSON 文件 并且能将es6 的模块化语法 转换成 浏览器能够识别的语法 
```

结论

- webpack 可以打包js 和 json 文件
- 能将`es6 的模块化`语法转换成浏览器能够识别的语法
- 能够压缩代码

缺点

- 不能编译打包 css img 等文件
- 不能将js 的es6 语法转成为 es5 一下的语法
- (改善) -> 使用webpack 配置文件解决, 自定义功能





### 打包less

- 概述: less 文件 wenpack 不能解析 需要借助loader
- 安装loader 

#### 运行指令

```bash
npm install css-loader style-loader less-loader less -D
$: webpack
```

#### 配置loader

- 所有的loader 都要在module 对象的rules 属性中
- rules 是一个数组 数组中每一个对象就是一个loader
- loader 的特点:  下载后无需引入,只需声明

```js
moudle: {
    reules:[
        {
            test: /\.less$/, //匹配所有less文件
            use:[
                'style-loader', //用于html文档中创建一个style标签,将样式加入
                'css-loader', //将less 编译后的css转换成CommonJs 的一个模块
                'less-loader' //将less 编译为css, 但不生成单独的css文件,在内存中
            ]
        }
    ]
}
```





### JS 语法检查

- 概述: 对于js基本语法错误/隐患, 进行提前检查
- 安装 loader

```js
npm install eslint-loader  eslint -D
```

备注

```js
{
	test:/\.js$/,
    exclude:'node_modules',
    enforce:'pre',//  提前加载使用
    use:{
        loader:"eslint-loader", //使用eslint-loader 解析
    }
}
```





### Js 语法转换

- 概述: 将浏览器不能识别的新语法转换成原来识别的旧语法,做浏览器兼容性处理
- 安装loader

```bash
npm install babel-loader @babel/core @babel/preset-env -D
```

#### 配置loader

```js
{
	test:/\.js$/,
    exclude:'node_modules',
    enforce:'pre',//  提前加载使用
    use:{
        loader:"babek-loader", 
        options:{
            presets:['@babel/preset-env']
        }
    }
}
```





### Js 兼容性处理

#### 方法一:  使用经典的polyfill 

```bash
npm install @babel/polyfill
// 包含ES6 的高级语法转换 不管编码人员用了哪些新语法,全部的新语法都进行转换 -> 400+ kb
```

index.js 中引入

```js
import '@babel/polyufill'
```

- 优点:  解决babel 只能转换部分低级语法的问题 (如 let const 结构赋值)  引入polyfill 可以转换高级语法 (如Promise)
- 缺点:  将所有的高级语法都进行了转换, 但实际上可能只使用了一部分
- 解决:   需要按需加载, 使用了什么高级语法 就转换什么, 其余的就不需要转换



#### 方法二:   按需引入借助 core-js

```bash
npm install core-js
```



```js
 //js语法转换+兼容性处理（es6->es5）
      {
        test: /\.js$/, //只检测js文件
        exclude: /node_modules/,
        use: {
          loader: "babel-loader",
          options: {
            presets: [
              ['@babel/preset-env', {
                  useBuiltIns: 'usage',  // 按需引入需要使用polyfill
                  corejs: { version: 3 }, // 解决不能够找到core-js的问题!!!
                  targets: { // 指定兼容性处理哪些浏览器
                    "chrome": "58",
                    "ie": "9"
                  }}]
            ],
            cacheDirectory: true, // 开启babel缓存
          }
        }
      },
```





### 打包样式文件中的图片资源

- 概述 图片文件webpack 不能解析, 需要借助loader 解析

```bash
npm install file-loader  url-loader  -D
```

补充:  url-loader 是对   file-loader 的上层封装  需要使用时配合 file-loader 使用

```js
      //使用url-loader处理样式文件中的图片
      {
        test: /\.(png|jpg|gif)$/,
        use: [
          {
            loader: 'url-loader',
            options: {
              limit: 8192,//// 8kb --> 8kb以下的图片会base64处理
              publicPath: 'images/',  // 决定图片的url路径
              outputPath: 'images', // 决定文件本地输出路径
              name: '[hash:5].[ext]' // 修改文件名称 [hash:8] hash值取8位  [ext] 文件扩展名
            },
          },
        ],
      },
```





### 打包html 文件 

- 概述 html 文件 webpack 不能解析, 需要借助插件编译解析
- 安装插件 Plugins

```
npm install html-webpack-plugin -D
```



#### 配置插件Plugins

```js
const HtmlWebpackPlugin = require('html-webpack-plugin');

  //配置插件
  plugins:[
    new HtmlWebpackPlugin({
      template: './src/index.html', // 以当前文件为模板创建新的HtML(1. 结构和原来一样 2. 会自动引入打包的资源)
    })
  ],
```





### 打包html 中图片资源

- 概述: html 中的图片url-loader 无法处理, 它只能处理js 中引入的图片 / 样式中的图片.  不能处理HTML 中img标签, 我们需要html-loader 处理
- 安装loader

```bash
npm install html-loader -D
```

#### 配置loader

```js
      //使用html-loader处理html中的标签资源
      {
        test: /\.(html)$/,
        use: {
          loader: 'html-loader'
        }
      },
```





### 打包其他资源

配置loader

```js
      //使用file-loader处理其他资源
      {
        test: /\.(eot|svg|woff|woff2|ttf|mp3|mp4|avi)$/,  // 处理其他资源
        loader: 'file-loader',
        options: {
          outputPath: 'media',
          name: '[hash:5].[ext]'
        }
      }
    ]
  },
```





### 自动编译打包运行 (live reload)

安装loader

```bash
npm install webpack-dev-server -D
```

修改webpack 配置对象 (注意  不是在loader中)

```js
  //配置自动化编译
  devServer: {
    open: true, // 自动打开浏览器
    compress: true, // 启动gzip压缩
    port: 3000, // 端口号
    hot:true //开启热模替换功能 HMR
  },
  //配置devtool实现源文件映射
  devtool:'cheap-module-eval-source-map'
}

```



- 修改url-loader 部分配置
  - 因为构建工具以build 为根目录. 不用再找build了
  - publichPath: "../build/images"  ->  'images/'

- 修改package.json 中script 的指令
  - "start": "webpack-dev-server"
- 运行指令: npm start



### HMR 热模替换

- 概述  是webpack 最有用的功能之一, 它允许在运行时更新所有类型的模块.而且无需完全刷新 (只更新变化的模块,不变的模块不更新)

#### 修改 devServer 配置

```
  hot:true //开启热模替换功能 HMR
```

问题: HTML 文件无法自动更新了, 需要增加一个入口

```
entry:['./src/js/index.js','./src/index.html'], //入口
```





### devTool