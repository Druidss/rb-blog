---
id: performance
title: performance
author: Adrian Yang
author_title: Front End Engineer
author_url: https://github.com/Druidss
author_image_url: https://avatars2.githubusercontent.com/u/40681152?s=460&u=e324c1f3465c768888c1fcf798b5f5eb1be9d60d&v=4
tags: [performance, JavaScript, Browser]
---





### 浏览器功能与组成

> 浏览器的主要功能总结起来就是一句话:将用户输入的`url`转变成可视化的图像。

<!--truncate-->

	网络：
		浏览器通过网络模块来下载各式各样的资源，例如html文本；javascript代码；样式表；图片；音视频文件等。
		网络部分尤为重要，因为它耗时长，而且需要安全访问互联网上的资源。
	
	资源管理：
		从网络下载，或者本地获取到的资源需要有高效的机制来管理它们。
		例如如何避免重复下载，资源如何缓存等等
	
	网页浏览：
		这是浏览器的核心也是最基本的功能，最重要的功能。
		如何将资源转变为可视化的结果。
		
	多页面管理
	插件与管理
	账户和同步
	安全机制
	开发者工具
	...



### 浏览器的内核(渲染引擎)	
> 在浏览器中有一个最重要的模块，它主要的作用把一切请求回来的资源变为可视化的图像。
> 这个模块就是浏览器内核，通常它也被称为渲染引擎。

内核由两部分组成:

**渲染引擎(layout engineer 或 Rendering Engine) 和 JS 引擎**

渲染引擎：

负责取得网页的内容（HTML、 XML 、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。



JS引擎则：

解析和执行 javascript 来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。

**常见的内核?**

Chrome:　Blink  2013年Webkit的一个分支 

Firefox:  Gecko

Safari: Webkit

IE: Trident  未开源

浏览器内核总结：


	IE---------->Trident
	
	Safari------>WebKit
		WebKit本身主要是由两个小引擎构成的，
			一个正是渲染引擎“WebCore”，
			另一个则是javascript解释引擎“JSCore”，
			它们均是从KDE的渲染引擎KHTML及javascript解释引擎KJS衍生而来。
			
	Chrome------>WebKit的分支引擎----->Blink
		 在13年发布的Chrome 28.0.1469.0版本开始，Chrome放弃Chromium引擎转
		 而使用最新的Blink引擎（基于WebKit2——苹果公司于2010年推出的新的WebKit引擎），
		 Blink对比上一代的引擎精简了代码、改善了DOM框架，也提升了安全性。
		 
	Opera
		旧版Opera 4至6版本 :Elektra排版引擎
		Opera7.0	:Presto渲染引擎
		Opera在2013年2月宣布放弃Presto:
					采用Chromium引擎;
					又转为Blink引擎;
					
	Firefox------>Gecko


### 进程与线程

进程: 程序的一次执行, 它占有一片独有的内存空间.是`操作系统`执行的基本单元。

- 一个进程中至少有一个运行的线程: 主线程,  进程启动后自动创建
- 一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的
- 一个进程内的数据可以供其中的多个线程直接共享，多个进程之间的数据是不能直接共享的



线程：是进程内的一个`独立执行单元`,是`CPU`调度的最小单元。程序运行的基本单元

- 线程池(thread pool): 保存多个线程对象的容器, 实现线程对象的反复利用



JS引擎是单线程运行的！（回忆事件轮询机制） 其中的分线程是浏览器为js开辟的







### 现代浏览器：多进程、多线程模型

#### 1.不堪回首的过去:

​		当你通过浏览器打开很多页面的时候,如果其中一个页面不响应了或者崩溃了,
​		那么随之而来的将会是更不幸的事情,你开打的所有页面都会得不到响应,
​		最让人不能忍受的是,其中的一些页面可能还包含了未保存或者未发送的信息、

#### 2.浏览器产商如何解决？

​	采用多进程模型,该模型可以带来的好处
​	①.避免因单个页面的不响应或者崩溃影响整个浏览器的稳定性
​	②.当第三方插件崩溃时,也不会影响整个浏览器的稳定性
​	③.安全

#### 3.浏览器到底有些什么进程

​	①.Browser进程:
​		浏览器的主进程,负责浏览器界面的显示,和各个页面的管理,
​		浏览器中所有其他类型进程的祖先,负责其他进程的的创建和销毁
​		它有且只有一个!!!!!
​	②.`Renderer`进程:
​		网页渲染进程,负责页面的渲染,可以有多个
​		当然渲染进程的数量不一定等于你开打网页的个数
​	③.各种插件进程
​	④.GPU进程	
​	移动设备的浏览器可能不太一样:
​		Android不支持插件,所以就没有插件进程
​		GPU演化成了Browser进程的一个线程
​		Renderer进程演化成了操作系统的一个服务进程,它仍然是独立的

#### 4.每个进程内部又有很多线程

多线程的目的主要是保持用户界面的高度响应
	例如:为了不让Browser进程的UI线程被其他耗时的操作(大文件的加载,本地文件读写)所阻塞,
		那么我们就把这些操作放到分线程中去处理。
在Renderer进程中,为了不让其他操作阻止渲染线程的高速执行,我们通常会将渲染过程`【管线化】`,
	利用计算机的多核优势,让渲染的不同阶段在不同的线程中执行		





## 一、浏览器渲染引擎
### 主要模块
* 一个渲染引擎主要包括：HTML解析器，CSS解析器，javascript引擎，布局layout模块，绘图模块
	* HTML解析器：解释HTML文档的解析器，主要作用是将HTML文本解释成DOM树。
	* CSS解析器：它的作用是为DOM中的各个元素对象计算出样式信息，为布局提供基础设施
	* Javascript引擎：使用Javascript代码可以修改网页的内容，也能修改css的信息，javascript引擎能够解释javascript代码，并通过DOM接口和CSS树接口来修改网页内容和样式信息，从而改变渲染的结果。
	* 布局（layout）：在DOM创建之后，Webkit需要将其中的元素对象同样式信息结合起来，计算他们的大小位置等布局信息，形成一个能表达这所有信息的内部表示模型
	* 绘图模块（paint）：使用图形库将布局计算后的各个网页的节点绘制成图像结果
	>备注：文档对象模型（Document Object Model，简称DOM）
	
### 大致的渲染过程
* 浏览器渲染页面的整个过程：浏览器会从上到下解析文档。
	1. 遇见 HTML 标记，调用HTML解析器解析为对应的 token （一个token就是一个标签文本的序列化）并构建 DOM 树（就是一块内存，保存着tokens，建立它们之间的关系）。
    2. 遇见 style/link 标记调用相应解析器处理CSS标记，并构建出CSS样式树。
    3. 遇见 script 标记 调用javascript引擎 处理script标记、绑定事件、修改DOM树/CSS树等
    4. 将 DOM树 与 CSS树 合并成一个渲染树。
    5. 根据渲染树来渲染，以计算每个节点的几何信息（这一过程需要依赖GPU）。
    6. 最终将各个节点绘制到屏幕上。

>以上这些模块依赖很多其他的基础模块，包括要使用到网络 存储 2D/3D图像 音频视频解码器 和 图片解码器。
>所以渲染引擎中还会包括如何使用这些依赖模块的部分。



### style 样式渲染

- style 样式标签中样式 由 html 解析器解析
- 浏览器加载资源是异步的
- 页面style 标签写的内部样式是异步解析的



### link 样式渲染 

- link 进来的样式, 是由css 解析器解析, 并且是同步解析的
- css 解析器会阻塞页面渲染, (也可以说link 进来的外部样式回阻塞页面渲染, 利用它避免闪屏)
- 推荐使用 link 方式去引入样式 (方便管理 + 防止闪屏 )




## 二、阻塞渲染		
### 1.关于css阻塞： 
    声明：只有link引入的外部css才能够产生阻塞。
    1.style标签中的样式：
        (1). 由html解析器进行解析；
        (2). 不阻塞浏览器渲染（可能会产生“闪屏现象”）；
        (3). 不阻塞DOM解析；


    2.link引入的外部css样式（推荐使用的方式）：
        (1). 由CSS解析器进行解析。
        (2). 阻塞浏览器[渲染](可以利用这种阻塞避免“闪屏现象”)。       
        (3). 阻塞其后面的js语句的执行
        (4). 不阻塞DOM的[解析](绝大多数浏览器的工作方式)：
                     
    3.优化核心理念：尽可能快的提高外部css加载速度
        	(1).使用CDN节点进行外部资源加速。
    	    (2).对css进行压缩(利用打包工具，比如webpack,gulp等)。
    	    (3).减少http请求数，将多个css文件合并。
    	    (4).优化样式表的代码

#### link 为什么 阻塞后续的js语句执行? 

```
如果后面js 的内容是获取元素的样式, 列如宽高等css控制的属性. 
如果不等样式解析完毕,后面的js就获得了错误的信息
由于浏览器也不知道后续的js的具体内容. 所以只好等前面所有的样式解析完毕之后, 再执行js
注意!
现代的浏览器愈发注重用户体验. 对于Webkit 内核的浏览器而言,
仅当脚本尝试访问样式属性, 或可能受尚未加载的样式表影响时, 它才会禁止该脚本.
```

#### 为什么不阻塞DOM解析:

```
DOM 解析 和 CSS 解析是两个并行的过程. 浏览器解析DOM 生成DOM Tree
解析 CSS 生成 CSS Tree. 最终形成render Tree. 再渲染页面
即: DOM 的解析 和 CSS 的解析 是并行执行的 (不阻塞DOM 解析)
```







### 2.关于js阻塞：

    1.阻塞后续DOM解析:
        	原因：浏览器不知道后续脚本的内容，如果先去解析了下面的DOM，而随后的js删除了后面所有的DOM，
              那么浏览器就做了无用功，浏览器无法预估脚本里面具体做了什么操作，例如像document.write
              这种操作，索性全部停住，等脚本执行完了，浏览器再继续向下解析DOM。	
    2.阻塞页面渲染:
        	原因：js中也可以给DOM设置样式，浏览器等该脚本执行完毕，渲染出一个最终结果，避免做无用功。
    3.阻塞后续js的执行:
        原因：维护依赖关系，例如：必须先引入jQuery再引入bootstrap



#### 3.备注
​    【备注1】：css的解析和js的执行是互斥的（互相排斥），css解析的时候js停止执行，js执行的时候css停止解析。
​    

    【备注2】：无论css阻塞，还是js阻塞，都不会阻塞浏览器加载外部资源（图片、视频、样式、脚本等）
                原因：浏览器始终处于一种：“先把请求发出去”的工作模式，只要是涉及到网络请求的内容，
                    无论是：图片、样式、脚本，都会先发送请求去获取资源，至于资源到本地之后什么时候用，
                    由浏览器自己协调。这种做法效率很高。
                    
    【备注3】：WebKit 和 Firefox 都进行了【预解析】这项优化。在执行js脚本时，浏览器的其他线程会预解析文档的其余部分，
              找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，
              从而提高总体速度。请注意，预解析器不会修改 DOM 树


>在上述的过程中，网页在加载和渲染过程中会触发“DOMContentLoaded”和“onload”事件
>分别是在DOM树构建（解析）完成之后，以及DOM树构建完并且网页所依赖的资源都加载完之后

* 上面介绍的是一个完整的渲染过程，但现代网页很多都是动态的，这意味着在渲染完成之后，由于网页的动画或者用户的交互，
	浏览器其实一直在不停地重复执行渲染过程。（重绘重排），以上的数字表示的是基本顺序，这不是严格一致的，
	这个过程可能重复也可能交叉